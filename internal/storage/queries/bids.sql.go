// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bids.sql

package queries

import (
	"context"

	"github.com/kak-tus/nan"
)

const createBid = `-- name: CreateBid :one
WITH user_check AS (
    SELECT 1
    FROM employee e
    JOIN organization_responsible ors ON e.id = ors.user_id
    WHERE e.username = $7
      AND ors.organization_id = $5
),
new_bid AS (
    INSERT INTO bids (
        name,
        description,
        status,
        tender_id,
        organization_id,
        user_id,
        author_type
    ) VALUES (
        $1, $2, $3, $4, $5, (
            SELECT id FROM employee WHERE username = $7
        ), $6
    ) 
    RETURNING id, name, description, status, organization_id, user_id, author_type, tender_id, version, created_at
)
SELECT id, name, description, status, organization_id, user_id, author_type, tender_id, version, created_at FROM new_bid
WHERE EXISTS (SELECT 1 FROM user_check)
`

type CreateBidParams struct {
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	TenderID       nan.NullInt32
	OrganizationID nan.NullInt32
	AuthorType     nan.NullString
	Username       string
}

type CreateBidRow struct {
	ID             int32
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	OrganizationID nan.NullInt32
	UserID         nan.NullInt32
	AuthorType     nan.NullString
	TenderID       nan.NullInt32
	Version        nan.NullInt32
	CreatedAt      nan.NullTime
}

func (q *Queries) CreateBid(ctx context.Context, arg CreateBidParams) (CreateBidRow, error) {
	row := q.db.QueryRow(ctx, createBid,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.TenderID,
		arg.OrganizationID,
		arg.AuthorType,
		arg.Username,
	)
	var i CreateBidRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.OrganizationID,
		&i.UserID,
		&i.AuthorType,
		&i.TenderID,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}

const createBidsHistory = `-- name: CreateBidsHistory :exec
INSERT INTO bids_history (
    bid_id,
    name,
    description,
    status,
    tender_id,
    organization_id,
    user_id,
    author_type,
    version,
    created_at
)
SELECT 
  id, 
  name, 
  description, 
  status, 
  tender_id, 
  organization_id, 
  user_id, 
  author_type,
  version, 
  created_at
FROM bids
WHERE bids.id = $1
`

func (q *Queries) CreateBidsHistory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, createBidsHistory, id)
	return err
}

const editBid = `-- name: EditBid :one
UPDATE bids AS b
SET
    name = COALESCE($2, b.name),
    description = COALESCE($3, b.description),
    updated_at = CURRENT_TIMESTAMP,
    version = version + 1
WHERE b.id = $1
  AND (
    (user_id = (SELECT e.id FROM employee e WHERE e.username = $4))
    OR
    (organization_id = (SELECT ors.organization_id FROM organization_responsible ors JOIN employee e ON ors.user_id = e.id WHERE e.username = $4))
  )
RETURNING b.id, b.name, b.description, b.status, b.user_id, b.author_type, b.tender_id, b.version, b.created_at
`

type EditBidParams struct {
	ID          int32
	Name        string
	Description nan.NullString
	Username    string
}

type EditBidRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	UserID      nan.NullInt32
	AuthorType  nan.NullString
	TenderID    nan.NullInt32
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) EditBid(ctx context.Context, arg EditBidParams) (EditBidRow, error) {
	row := q.db.QueryRow(ctx, editBid,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Username,
	)
	var i EditBidRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.UserID,
		&i.AuthorType,
		&i.TenderID,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}

const getBidReviews = `-- name: GetBidReviews :many
SELECT r.id, r.bid_id, r.user_id, r.feedback, r.created_at
FROM bid_feedbacks r
JOIN bids b ON r.bid_id = b.id
WHERE b.tender_id = $1
  AND b.user_id = (
    SELECT id
    FROM employee
    WHERE employee.username = $2
  )
  AND EXISTS (
    SELECT 1
    FROM organization_responsible ors
    JOIN employee e ON ors.user_id = e.id
    WHERE e.username = $3
      AND ors.organization_id = b.organization_id
)
ORDER BY r.created_at DESC
LIMIT $4 OFFSET $5
`

type GetBidReviewsParams struct {
	TenderID   nan.NullInt32
	Username   string
	Username_2 string
	Limit      int32
	Offset     int32
}

func (q *Queries) GetBidReviews(ctx context.Context, arg GetBidReviewsParams) ([]BidFeedback, error) {
	rows, err := q.db.Query(ctx, getBidReviews,
		arg.TenderID,
		arg.Username,
		arg.Username_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BidFeedback
	for rows.Next() {
		var i BidFeedback
		if err := rows.Scan(
			&i.ID,
			&i.BidID,
			&i.UserID,
			&i.Feedback,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBidStatus = `-- name: GetBidStatus :one
SELECT b.status
FROM bids b
JOIN employee e ON b.user_id = e.id
WHERE b.id = $1
  AND e.username = $2
UNION
SELECT b.status
FROM bids b
JOIN organization_responsible ors ON b.organization_id = ors.organization_id
JOIN employee e ON ors.user_id = e.id
WHERE b.id = $1
  AND e.username = $2
`

type GetBidStatusParams struct {
	ID       int32
	Username string
}

func (q *Queries) GetBidStatus(ctx context.Context, arg GetBidStatusParams) (NullStatusType, error) {
	row := q.db.QueryRow(ctx, getBidStatus, arg.ID, arg.Username)
	var status NullStatusType
	err := row.Scan(&status)
	return status, err
}

const getBidsForTender = `-- name: GetBidsForTender :many
SELECT 
  b.id, 
  b.name, 
  b.description, 
  b.status, 
  b.author_type, 
  b.user_id, 
  b.tender_id,
  b.version, 
  b.created_at
FROM bids AS b
WHERE b.tender_id = $1
  AND EXISTS (
      SELECT 1
      FROM employee e
      JOIN organization_responsible ors ON e.id = ors.user_id
      WHERE e.username = $2
        AND (b.user_id = e.id OR b.organization_id = ors.organization_id)
  )
ORDER BY b.name ASC
LIMIT $3 OFFSET $4
`

type GetBidsForTenderParams struct {
	TenderID nan.NullInt32
	Username string
	Limit    int32
	Offset   int32
}

type GetBidsForTenderRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	AuthorType  nan.NullString
	UserID      nan.NullInt32
	TenderID    nan.NullInt32
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) GetBidsForTender(ctx context.Context, arg GetBidsForTenderParams) ([]GetBidsForTenderRow, error) {
	rows, err := q.db.Query(ctx, getBidsForTender,
		arg.TenderID,
		arg.Username,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBidsForTenderRow
	for rows.Next() {
		var i GetBidsForTenderRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.AuthorType,
			&i.UserID,
			&i.TenderID,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBids = `-- name: GetUserBids :many
SELECT 
  b.id, 
  b.name, 
  b.description, 
  b.status, 
  b.tender_id, 
  b.organization_id, 
  b.user_id, 
  b.author_type,
  b.tender_id, 
  b.version, 
  b.created_at
FROM bids AS b
INNER JOIN employee AS e ON b.user_id = e.id
WHERE e.username = $1
ORDER BY b.name ASC
LIMIT $2 OFFSET $3
`

type GetUserBidsParams struct {
	Username string
	Limit    int32
	Offset   int32
}

type GetUserBidsRow struct {
	ID             int32
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	TenderID       nan.NullInt32
	OrganizationID nan.NullInt32
	UserID         nan.NullInt32
	AuthorType     nan.NullString
	TenderID_2     nan.NullInt32
	Version        nan.NullInt32
	CreatedAt      nan.NullTime
}

func (q *Queries) GetUserBids(ctx context.Context, arg GetUserBidsParams) ([]GetUserBidsRow, error) {
	rows, err := q.db.Query(ctx, getUserBids, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBidsRow
	for rows.Next() {
		var i GetUserBidsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.TenderID,
			&i.OrganizationID,
			&i.UserID,
			&i.AuthorType,
			&i.TenderID_2,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rollbackBid = `-- name: RollbackBid :one
WITH 
user_check AS (
    SELECT 1
    FROM employee e
    JOIN organization_responsible ors ON e.id = ors.user_id
    JOIN bids b ON ors.organization_id = b.organization_id
    WHERE e.username = $3
      AND b.id = $1
),
current_bid AS (
    SELECT b.id, b.tender_id, b.organization_id, b.user_id, b.author_type, b.name, b.description, b.status, b.version, b.created_at, b.updated_at
    FROM bids AS b
    WHERE b.id = $1
      AND b.version = (SELECT MAX(version) FROM bids WHERE id = $1)
),
previous_version AS (
    SELECT bh.bid_id, bh.tender_id, bh.organization_id, bh.user_id, bh.author_type, bh.name, bh.description, bh.status, bh.version, bh.created_at, bh.updated_at
    FROM bids_history bh
    WHERE bh.bid_id = $1
      AND bh.version = $2
),
updated_bid AS (
    UPDATE bids
    SET
        name = previous_version.name,
        description = previous_version.description,
        status = previous_version.status,
        version = current_bid.version + 1,
        updated_at = CURRENT_TIMESTAMP
    FROM previous_version, current_bid
    WHERE bids.id = $1
      AND current_bid.version = (SELECT MAX(version) FROM bids WHERE id = $1)
      AND current_bid.id = bids.id
      AND EXISTS (SELECT 1 FROM user_check)
    RETURNING bids.id, bids.tender_id, bids.organization_id, bids.user_id, bids.name, bids.description, bids.status, bids.author_type, bids.version, bids.created_at, bids.updated_at
),
insert_history AS (
    INSERT INTO bids_history (bid_id, tender_id, organization_id, user_id, author_type, name, description, status, version, created_at, updated_at)
    SELECT id, tender_id, organization_id, user_id, author_type, name, description, status, version, created_at, updated_at
    FROM current_bid
    RETURNING id, tender_id, bid_id, organization_id, user_id, name, description, status, author_type, version, created_at, updated_at
)
SELECT id, tender_id, organization_id, user_id, name, description, status, author_type, version, created_at, updated_at FROM updated_bid
`

type RollbackBidParams struct {
	ID       int32
	Version  nan.NullInt32
	Username string
}

type RollbackBidRow struct {
	ID             int32
	TenderID       nan.NullInt32
	OrganizationID nan.NullInt32
	UserID         nan.NullInt32
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	AuthorType     nan.NullString
	Version        nan.NullInt32
	CreatedAt      nan.NullTime
	UpdatedAt      nan.NullTime
}

func (q *Queries) RollbackBid(ctx context.Context, arg RollbackBidParams) (RollbackBidRow, error) {
	row := q.db.QueryRow(ctx, rollbackBid, arg.ID, arg.Version, arg.Username)
	var i RollbackBidRow
	err := row.Scan(
		&i.ID,
		&i.TenderID,
		&i.OrganizationID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.AuthorType,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const submitBidDecision = `-- name: SubmitBidDecision :one
WITH user_check AS (
    SELECT EXISTS (
        SELECT 1
        FROM employee e
        JOIN organization_responsible ors ON e.id = ors.user_id
        JOIN tender t ON t.id = (SELECT tender_id FROM bids WHERE bids.id = $1)
        WHERE e.username = $3
          AND ors.organization_id = t.organization_id
    ) AS has_permission
),
update_bid AS (
    UPDATE bids
    SET
        status = CASE
            WHEN $2::text = 'Rejected' THEN 'Rejected'
            WHEN $2::text = 'Approved'
                 AND (SELECT COUNT(*) FROM bids_decisions WHERE bid_id = $1 AND decision = 'Approved') >= LEAST(3, (SELECT COUNT(DISTINCT user_id) 
                 FROM organization_responsible WHERE organization_id = (SELECT organization_id FROM bids WHERE id = $1))) THEN 'Approved'
            ELSE status
        END,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = $1
      AND EXISTS (SELECT 1 FROM user_check WHERE has_permission)
    RETURNING id, name, description, status, organization_id, user_id, author_type, tender_id, version, created_at
),
tender_update AS (
    UPDATE tender
    SET status = 'Closed'
    WHERE id = (SELECT tender_id FROM bids WHERE id = $1)
      AND EXISTS (SELECT 1 FROM update_bid WHERE status = 'Approved')
    RETURNING id, status
),
insert_history AS (
    INSERT INTO bids_history (bid_id, name, description, status, version, created_at, updated_at)
    SELECT id, name, description, status, version, created_at, updated_at
    FROM update_bid
    RETURNING id, name, description, status, version, created_at, updated_at
)
SELECT id, name, description, status, organization_id, user_id, author_type, tender_id, version, created_at FROM update_bid
`

type SubmitBidDecisionParams struct {
	ID       int32
	Column2  string
	Username string
}

type SubmitBidDecisionRow struct {
	ID             int32
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	OrganizationID nan.NullInt32
	UserID         nan.NullInt32
	AuthorType     nan.NullString
	TenderID       nan.NullInt32
	Version        nan.NullInt32
	CreatedAt      nan.NullTime
}

func (q *Queries) SubmitBidDecision(ctx context.Context, arg SubmitBidDecisionParams) (SubmitBidDecisionRow, error) {
	row := q.db.QueryRow(ctx, submitBidDecision, arg.ID, arg.Column2, arg.Username)
	var i SubmitBidDecisionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.OrganizationID,
		&i.UserID,
		&i.AuthorType,
		&i.TenderID,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}

const submitBidFeedback = `-- name: SubmitBidFeedback :one
WITH user_check AS (
    SELECT EXISTS (
        SELECT 1
        FROM employee e
        JOIN organization_responsible ors ON e.id = ors.user_id
        JOIN tender t ON t.id = (SELECT tender_id FROM bids WHERE id = $1)
        WHERE e.username = $3
          AND ors.organization_id = t.organization_id
    ) AS has_permission
),
insert_feedback AS (
    INSERT INTO bid_feedbacks (bid_id, user_id, feedback, created_at)
    SELECT $1, e.id, $2, CURRENT_TIMESTAMP
    FROM employee e
    WHERE e.username = $3
      AND (SELECT has_permission FROM user_check) = true
    RETURNING id AS feedback_id
)
SELECT b.id, b.name, b.description, b.status, b.user_id, b.author_type, b.version, b.tender_id, b.created_at, b.updated_at
FROM bids b
WHERE b.id = $1
`

type SubmitBidFeedbackParams struct {
	ID       int32
	Feedback string
	Username string
}

type SubmitBidFeedbackRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	UserID      nan.NullInt32
	AuthorType  nan.NullString
	Version     nan.NullInt32
	TenderID    nan.NullInt32
	CreatedAt   nan.NullTime
	UpdatedAt   nan.NullTime
}

func (q *Queries) SubmitBidFeedback(ctx context.Context, arg SubmitBidFeedbackParams) (SubmitBidFeedbackRow, error) {
	row := q.db.QueryRow(ctx, submitBidFeedback, arg.ID, arg.Feedback, arg.Username)
	var i SubmitBidFeedbackRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.UserID,
		&i.AuthorType,
		&i.Version,
		&i.TenderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBidStatus = `-- name: UpdateBidStatus :one
UPDATE bids
SET status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE bids.id = $1
  AND (
    EXISTS (
        SELECT 1
        FROM employee e
        WHERE e.username = $3
          AND e.id = (SELECT user_id FROM bids WHERE id = $1)
    )
    OR
    EXISTS (
        SELECT 1
        FROM organization_responsible ors
        JOIN employee e ON ors.user_id = e.id
        WHERE e.username = $3
          AND ors.organization_id = (SELECT organization_id FROM bids WHERE id = $1)
    )
)
RETURNING bids.id, name, description, status, user_id, author_type, tender_id, version, created_at, updated_at
`

type UpdateBidStatusParams struct {
	ID       int32
	Status   NullStatusType
	Username string
}

type UpdateBidStatusRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	UserID      nan.NullInt32
	AuthorType  nan.NullString
	TenderID    nan.NullInt32
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
	UpdatedAt   nan.NullTime
}

func (q *Queries) UpdateBidStatus(ctx context.Context, arg UpdateBidStatusParams) (UpdateBidStatusRow, error) {
	row := q.db.QueryRow(ctx, updateBidStatus, arg.ID, arg.Status, arg.Username)
	var i UpdateBidStatusRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.UserID,
		&i.AuthorType,
		&i.TenderID,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
