// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tenders.sql

package queries

import (
	"context"

	"github.com/kak-tus/nan"
)

const createTender = `-- name: CreateTender :one
INSERT INTO tender (
    name,
    description,
    service_type,
    status,
    organization_id,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, (
        SELECT id FROM employee WHERE username = $6
    )
) RETURNING id, name, description, service_type, status, version, created_at
`

type CreateTenderParams struct {
	Name           string
	Description    nan.NullString
	ServiceType    nan.NullString
	Status         NullStatusType
	OrganizationID nan.NullInt32
	Username       string
}

type CreateTenderRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	ServiceType nan.NullString
	Status      NullStatusType
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) CreateTender(ctx context.Context, arg CreateTenderParams) (CreateTenderRow, error) {
	row := q.db.QueryRow(ctx, createTender,
		arg.Name,
		arg.Description,
		arg.ServiceType,
		arg.Status,
		arg.OrganizationID,
		arg.Username,
	)
	var i CreateTenderRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ServiceType,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}

const createTenderHistory = `-- name: CreateTenderHistory :exec
INSERT INTO tender_history (
    tender_id, 
    name, 
    description, 
    service_type, 
    status, 
    version, 
    created_at
)
SELECT id, name, description, service_type, status, version, created_at
FROM tender
WHERE tender.id = $1
`

func (q *Queries) CreateTenderHistory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, createTenderHistory, id)
	return err
}

const editTender = `-- name: EditTender :one
UPDATE tender t
SET name = COALESCE($1, t.name),
    description = COALESCE($2, t.description),
    service_type = COALESCE($3, t.service_type),
    version = version + 1
FROM employee e
JOIN organization_responsible ors ON e.id = ors.user_id
WHERE t.id = $4
    AND e.username = $5
    AND ors.organization_id = (SELECT organization_id FROM tender WHERE id = t.id)
RETURNING t.id, t.name, t.description, t.service_type, t.status, t.version, t.created_at
`

type EditTenderParams struct {
	Name        string
	Description nan.NullString
	ServiceType nan.NullString
	ID          int32
	Username    string
}

type EditTenderRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	ServiceType nan.NullString
	Status      NullStatusType
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) EditTender(ctx context.Context, arg EditTenderParams) (EditTenderRow, error) {
	row := q.db.QueryRow(ctx, editTender,
		arg.Name,
		arg.Description,
		arg.ServiceType,
		arg.ID,
		arg.Username,
	)
	var i EditTenderRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ServiceType,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}

const getTenderStatus = `-- name: GetTenderStatus :one
SELECT t.status
FROM tender AS t
LEFT JOIN employee AS e ON t.created_by = e.id
WHERE (t.id = $1 AND e.username = $2) OR (t.id = $1 AND t.status = 'Published')
ORDER BY t.name ASC
LIMIT 1
`

type GetTenderStatusParams struct {
	ID       int32
	Username string
}

func (q *Queries) GetTenderStatus(ctx context.Context, arg GetTenderStatusParams) (NullStatusType, error) {
	row := q.db.QueryRow(ctx, getTenderStatus, arg.ID, arg.Username)
	var status NullStatusType
	err := row.Scan(&status)
	return status, err
}

const getTenders = `-- name: GetTenders :many
SELECT id, name, description, status, service_type, version, created_at
FROM tender
WHERE status = 'Published'
  AND ($1::text[] IS NULL OR array_length($1::text[], 1) = 0 OR service_type = ANY($1::text[]))
ORDER BY name ASC
LIMIT $2 OFFSET $3
`

type GetTendersParams struct {
	Column1 []string
	Limit   int32
	Offset  int32
}

type GetTendersRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	ServiceType nan.NullString
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) GetTenders(ctx context.Context, arg GetTendersParams) ([]GetTendersRow, error) {
	rows, err := q.db.Query(ctx, getTenders, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTendersRow
	for rows.Next() {
		var i GetTendersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.ServiceType,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTenders = `-- name: GetUserTenders :many
SELECT t.id, t.name, t.description, t.status, t.service_type, t.version, t.created_at
FROM tender AS t
INNER JOIN employee AS e ON t.created_by = e.id
WHERE e.username = $1
ORDER BY t.name ASC
LIMIT $2 OFFSET $3
`

type GetUserTendersParams struct {
	Username string
	Limit    int32
	Offset   int32
}

type GetUserTendersRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	ServiceType nan.NullString
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) GetUserTenders(ctx context.Context, arg GetUserTendersParams) ([]GetUserTendersRow, error) {
	rows, err := q.db.Query(ctx, getUserTenders, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTendersRow
	for rows.Next() {
		var i GetUserTendersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.ServiceType,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rollbackTender = `-- name: RollbackTender :one
WITH
user_check AS (
    SELECT 1
    FROM employee e
    JOIN organization_responsible as ors ON e.id = ors.user_id
    JOIN tender t ON ors.organization_id = t.organization_id
    WHERE e.username = $3
      AND t.id = $1
),
current_tender AS (
    SELECT id, name, description, service_type, status, version, created_at, updated_at
    FROM tender
    WHERE id = $1
      AND version = (SELECT MAX(version) FROM tender WHERE id = $1)
),
previous_version AS (
    SELECT th.tender_id, th.name, th.description, th.service_type, th.status, th.version, th.created_at, updated_at
    FROM tender_history th
    WHERE th.tender_id = $1
      AND th.version = $2
),
updated_tender AS (
    UPDATE tender
    SET
        name = previous_version.name,
        description = previous_version.description,
        service_type = previous_version.service_type,
        status = previous_version.status,
        version = current_tender.version + 1,
        updated_at = CURRENT_TIMESTAMP
    FROM previous_version, current_tender
    WHERE tender.id = $1
      AND current_tender.version = (SELECT MAX(version) FROM tender WHERE id = $1)
      AND current_tender.id = previous_version.tender_id
      AND EXISTS (SELECT 1 FROM user_check)
    RETURNING tender.id, tender.organization_id, tender.created_by, tender.name, tender.description, tender.status, tender.service_type, tender.version, tender.created_at, tender.updated_at
),
insert_history AS (
    INSERT INTO tender_history (tender_id, name, description, service_type, status, version, created_at, updated_at)
    SELECT id, name, description, service_type, status, version, created_at, updated_at
    FROM current_tender
    RETURNING id, tender_id, name, description, service_type, status, version, created_at, updated_at
)
SELECT id, organization_id, created_by, name, description, status, service_type, version, created_at, updated_at FROM updated_tender
`

type RollbackTenderParams struct {
	ID       int32
	Version  nan.NullInt32
	Username string
}

type RollbackTenderRow struct {
	ID             int32
	OrganizationID nan.NullInt32
	CreatedBy      nan.NullInt32
	Name           string
	Description    nan.NullString
	Status         NullStatusType
	ServiceType    nan.NullString
	Version        nan.NullInt32
	CreatedAt      nan.NullTime
	UpdatedAt      nan.NullTime
}

func (q *Queries) RollbackTender(ctx context.Context, arg RollbackTenderParams) (RollbackTenderRow, error) {
	row := q.db.QueryRow(ctx, rollbackTender, arg.ID, arg.Version, arg.Username)
	var i RollbackTenderRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.CreatedBy,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.ServiceType,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTenderStatus = `-- name: UpdateTenderStatus :one
UPDATE tender
SET status = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE tender.id = $2
    AND EXISTS (
        SELECT 1
        FROM employee AS e
        JOIN organization_responsible AS ors ON e.id = ors.user_id
        WHERE e.username = $3
            AND ors.organization_id = (SELECT tender.organization_id FROM tender WHERE tender.id = $2)
    )
RETURNING tender.id, name, description, status, service_type, version, created_at
`

type UpdateTenderStatusParams struct {
	Status   NullStatusType
	ID       int32
	Username string
}

type UpdateTenderStatusRow struct {
	ID          int32
	Name        string
	Description nan.NullString
	Status      NullStatusType
	ServiceType nan.NullString
	Version     nan.NullInt32
	CreatedAt   nan.NullTime
}

func (q *Queries) UpdateTenderStatus(ctx context.Context, arg UpdateTenderStatusParams) (UpdateTenderStatusRow, error) {
	row := q.db.QueryRow(ctx, updateTenderStatus, arg.Status, arg.ID, arg.Username)
	var i UpdateTenderStatusRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.ServiceType,
		&i.Version,
		&i.CreatedAt,
	)
	return i, err
}
